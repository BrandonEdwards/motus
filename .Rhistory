difftime(loc$ts, maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)), (loc$ts - 86400), POSIXct.out=T, direction='sunset')$time, units = units))
loc$ts_to_rise <- ifelse(loc$ts < loc$sunrise, difftime(loc$sunrise, loc$ts, units = units),
difftime(maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)), (loc$ts + 86400), POSIXct.out=T, direction='sunrise')$time, loc$ts, units = units))
loc$ts_since_rise <- ifelse(loc$ts > loc$sunrise, difftime(loc$ts, loc$sunrise, units = units),
difftime(loc$ts, maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)), (loc$ts - 86400), POSIXct.out=T, direction='sunrise')$time, units = units))
data <- merge(loc, loc_na, all = TRUE)
data <- select(jb, -recvDeployLat, -recvDeployLon)
data <- data %>% collect %>% as.data.frame
data$ts <- as_datetime(data$ts, tz = "UTC")
data$lat <- ifelse(is.na(data$lat) == TRUE, data$recvDeployLat,  ## fill in as many GPS missing lat/lons with deployment lat/lons
ifelse(data$lat == 0, data$recvDeployLat, data$lat))
data$lon <- ifelse(is.na(data$lon) == TRUE, data$recvDeployLon,
ifelse(data$lon == 0, data$recvDeployLon, data$lon))
cols <- c("lat", "lon", "ts") ## Select columns that can't contain NA values
loc_na <- data[!complete.cases(data[cols]),] ## new dataframe with NA values in lat, lon, or ts
loc <- data[complete.cases(data[cols]),] ## new dataframe with no NA values in lat, lon, or ts
loc$sunrise <- maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)),loc$ts, POSIXct.out=T, direction='sunrise')$time
loc$sunset <- maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)),loc$ts, POSIXct.out=T, direction='sunset')$time
## to get time difference, must take into account whether you are going to/from sunrise/sunset from the
## previous or next day, this depends on when the detection was in relation to sunrise/sunset times for that day.
loc$ts_to_set <- ifelse(loc$ts < loc$sunset, difftime(loc$sunset, loc$ts, units = units),
difftime(maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)), (loc$ts + 86400), POSIXct.out=T, direction='sunset')$time, loc$ts, units = units))
str(loc)
unique(loc$lat)
units - "hours"
units = "hours"
## to get time difference, must take into account whether you are going to/from sunrise/sunset from the
## previous or next day, this depends on when the detection was in relation to sunrise/sunset times for that day.
loc$ts_to_set <- ifelse(loc$ts < loc$sunset, difftime(loc$sunset, loc$ts, units = units),
difftime(maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)), (loc$ts + 86400), POSIXct.out=T, direction='sunset')$time, loc$ts, units = units))
loc$ts_since_set <- ifelse(loc$ts > loc$sunset, difftime(loc$ts, loc$sunset, units = units),
difftime(loc$ts, maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)), (loc$ts - 86400), POSIXct.out=T, direction='sunset')$time, units = units))
loc$ts_to_rise <- ifelse(loc$ts < loc$sunrise, difftime(loc$sunrise, loc$ts, units = units),
difftime(maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)), (loc$ts + 86400), POSIXct.out=T, direction='sunrise')$time, loc$ts, units = units))
loc$ts_since_rise <- ifelse(loc$ts > loc$sunrise, difftime(loc$ts, loc$sunrise, units = units),
difftime(loc$ts, maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)), (loc$ts - 86400), POSIXct.out=T, direction='sunrise')$time, units = units))
data <- merge(loc, loc_na, all = TRUE)
View(data)
data <- select(jb, -recvDeployLon, recvDeployLat)
fun <- function(data, units = "hours"){
data <- data %>% collect %>% as.data.frame
data$ts <- as_datetime(data$ts, tz = "UTC")
data$lat <- ifelse(is.na(data$lat) == TRUE, data$recvDeployLat,  ## fill in as many GPS missing lat/lons with deployment lat/lons
ifelse(data$lat == 0, data$recvDeployLat, data$lat))
data$lon <- ifelse(is.na(data$lon) == TRUE, data$recvDeployLon,
ifelse(data$lon == 0, data$recvDeployLon, data$lon))
cols <- c("lat", "lon", "ts") ## Select columns that can't contain NA values
loc_na <- data[!complete.cases(data[cols]),] ## new dataframe with NA values in lat, lon, or ts
loc <- data[complete.cases(data[cols]),] ## new dataframe with no NA values in lat, lon, or ts
loc$sunrise <- maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)),loc$ts, POSIXct.out=T, direction='sunrise')$time
loc$sunset <- maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)),loc$ts, POSIXct.out=T, direction='sunset')$time
## to get time difference, must take into account whether you are going to/from sunrise/sunset from the
## previous or next day, this depends on when the detection was in relation to sunrise/sunset times for that day.
loc$ts_to_set <- ifelse(loc$ts < loc$sunset, difftime(loc$sunset, loc$ts, units = units),
difftime(maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)), (loc$ts + 86400), POSIXct.out=T, direction='sunset')$time, loc$ts, units = units))
loc$ts_since_set <- ifelse(loc$ts > loc$sunset, difftime(loc$ts, loc$sunset, units = units),
difftime(loc$ts, maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)), (loc$ts - 86400), POSIXct.out=T, direction='sunset')$time, units = units))
loc$ts_to_rise <- ifelse(loc$ts < loc$sunrise, difftime(loc$sunrise, loc$ts, units = units),
difftime(maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)), (loc$ts + 86400), POSIXct.out=T, direction='sunrise')$time, loc$ts, units = units))
loc$ts_since_rise <- ifelse(loc$ts > loc$sunrise, difftime(loc$ts, loc$sunrise, units = units),
difftime(loc$ts, maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)), (loc$ts - 86400), POSIXct.out=T, direction='sunrise')$time, units = units))
data <- merge(loc, loc_na, all = TRUE)
return(data)
}
tmp <- fun(data)
fun <- function(data, units = "hours"){
data <- data %>% collect %>% as.data.frame
data$ts <- as_datetime(data$ts, tz = "UTC")
cols <- c("lat", "lon", "ts") ## Select columns that can't contain NA values
loc_na <- data[!complete.cases(data[cols]),] ## new dataframe with NA values in lat, lon, or ts
loc <- data[complete.cases(data[cols]),] ## new dataframe with no NA values in lat, lon, or ts
loc$sunrise <- maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)),loc$ts, POSIXct.out=T, direction='sunrise')$time
loc$sunset <- maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)),loc$ts, POSIXct.out=T, direction='sunset')$time
## to get time difference, must take into account whether you are going to/from sunrise/sunset from the
## previous or next day, this depends on when the detection was in relation to sunrise/sunset times for that day.
loc$ts_to_set <- ifelse(loc$ts < loc$sunset, difftime(loc$sunset, loc$ts, units = units),
difftime(maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)), (loc$ts + 86400), POSIXct.out=T, direction='sunset')$time, loc$ts, units = units))
loc$ts_since_set <- ifelse(loc$ts > loc$sunset, difftime(loc$ts, loc$sunset, units = units),
difftime(loc$ts, maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)), (loc$ts - 86400), POSIXct.out=T, direction='sunset')$time, units = units))
loc$ts_to_rise <- ifelse(loc$ts < loc$sunrise, difftime(loc$sunrise, loc$ts, units = units),
difftime(maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)), (loc$ts + 86400), POSIXct.out=T, direction='sunrise')$time, loc$ts, units = units))
loc$ts_since_rise <- ifelse(loc$ts > loc$sunrise, difftime(loc$ts, loc$sunrise, units = units),
difftime(loc$ts, maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)), (loc$ts - 86400), POSIXct.out=T, direction='sunrise')$time, units = units))
data <- merge(loc, loc_na, all = TRUE)
return(data)
}
tmp <- fun(jb)
tmp1 <- fun(alltags)
fun<- function(data, lat.name = "lat", lon.name = "lon", ts.name = "ts"){
if(class(data$ts) !="POSIXct") stop('ts must be in class POSIXct')
#  cols <- c("lat", "lon", "ts") ## Select columns that can't contain NA values
#  loc_na1 <- data[!complete.cases(data[cols]),] ## new dataframe with NA values in lat, lon, or ts
test$lat.name[is.na(test$lat.name)] <- 0
loc <- filter_(data, paste(lat.name, "!=",0), paste(lon.name, "!=",0))
cols_to_filter = c("lat.name", "ant.name")
lat.na <- filter_(data, paste(lat.name, "!=",0) & paste(ant.name, "!=",0))
lon.na <- filter_(data, paste(ant.name, "!=",0))
na <- suppressMessages(full_join(lat.na, lon.na)) ## join grouped data with data
lat.full <- filter_(data, paste(lat.name, "!=",0))
lon.full <- filter_(data, paste(ant.name, "!=",0))
full <- suppressMessages(full_join(lat.full, lon.full)) ## join grouped data with data
loc1 <- filter_(data, interp(~var == 0, var = as.name(lat.name)) | interp(~var == 0, var = as.name(lat.name)))
loc2 <- filter_(interp(~var == 0, var = as.name(ant.name)))
loc1 <- subset(data, lat ==0 | lon == 0 | ant == 0)
loc2 <- filter(data, is.na(lat))
#  loc <- data[complete.cases(data[cols]),] ## new dataframe with no NA values in lat, lon, or ts
loc_na <- filter_(data, !is.na(paste(lat.name, "!=",0)), !is.na(paste(lon.name, "!=",0)), !is.na(paste(ts.name, "!=",0))) ## new dataframe with no NA values in lat, lon, or ts
loc$sunrise <- maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)),loc$ts, POSIXct.out=T, direction='sunrise')$time ## sunrise column
loc$sunset <- maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)),loc$ts, POSIXct.out=T, direction='sunset')$time ## sunset column
data <- suppressMessages(full_join(loc, loc_na)) ## merge back with rows that contain NA values
return(data)
}
tmp <- fun(jb)
fun <- function(data, units = "hours"){
data <- data %>% collect %>% as.data.frame
data$ts <- as_datetime(data$ts, tz = "UTC")
cols <- c("lat", "lon", "ts") ## Select columns that can't contain NA values
loc_na <- data[!complete.cases(data[cols]),] ## new dataframe with NA values in lat, lon, or ts
loc <- data[complete.cases(data[cols]),] ## new dataframe with no NA values in lat, lon, or ts
loc$sunrise <- maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)),loc$ts, POSIXct.out=T, direction='sunrise')$time
loc$sunset <- maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)),loc$ts, POSIXct.out=T, direction='sunset')$time
data <- merge(loc, loc_na, all = TRUE)
return(data)
}
tmp <- fun(jb)
View(tmp)
fun<- function(data){
data <- data %>% collect %>% as.data.frame
data$ts <- as_datetime(data$ts, tz = "UTC")
cols <- c("lat", "lon", "ts") ## Select columns that can't contain NA values
loc_na <- data[!complete.cases(data[cols]),] ## new dataframe with NA values in lat, lon, or ts
loc <- data[complete.cases(data[cols]),] ## new dataframe with no NA values in lat, lon, or ts
loc$sunrise <- maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)),loc$ts, POSIXct.out=T, direction='sunrise')$time
loc$sunset <- maptools::sunriset(as.matrix(dplyr::select(loc,lon,lat)),loc$ts, POSIXct.out=T, direction='sunset')$time
data <- merge(loc, loc_na, all = TRUE)
return(data)
}
tmp <- fun(alltags)
View(tmp)
fun<- function(data, lat.name = "lat", tagsPerPanel = 5){
data = data %>% mutate(round_ts = 3600*round(as.numeric(ts)/3600, 0)) ## round times to the hour
data = distinct(select(data, id, site, round_ts, lat, recvDeployLat, lon, recvDeployLon, fullID))
dataGrouped <- dplyr::filter_(data, paste(lat.name, "!=", 0)) %>% group_by(site) %>%
summarise_(.dots = setNames(paste0('mean(',lat.name,')'), 'meanlat')) ## get summary of mean lats by site
data <- inner_join(data, dataGrouped, by = "site") ## join grouped data with data
data <- select(data, id, site, round_ts, lat, meanlat, fullID) %>% distinct %>% collect %>% as.data.frame
data$meanlat = round(data$meanlat, digits = 2) ## round to 2 significant digits
data$sitelat <- as.factor(paste(data$site, data$meanlat, sep = " ")) ## new column with site and lat
data <- within(data, sitelat <- reorder(sitelat, (lat))) ## order sitelat by latitude
data$round_ts <- lubridate::as_datetime(data$round_ts, tz = "UTC")
## We want to plot multiple tags per panel, so sort their labels and create a grouping factor
## Note that labels are sorted in increasing order by ID
labs = data$fullID[order(data$id,data$fullID)]
dup = duplicated(labs)
tagLabs = labs[!dup]
tagGroupIDs = data$id[order(data$id,data$fullID)][!dup]
tagGroup = 1 + floor((0:length(tagLabs)) / tagsPerPanel)
ngroup = length(tagGroup)
names(tagGroup) = tagLabs
tagGroupFactor = tagGroup[as.character(data$fullID)]
tagGroupLabels = tapply(tagGroupIDs, 1 + floor((0:(length(tagGroupIDs)-1)) / tagsPerPanel), function(data) paste("IDs:", paste(sort(unique(data)), collapse=",")))
data$tagGroupFactor = factor(tagGroupFactor, labels=tagGroupLabels, ordered=TRUE)
data <- unique(subset(data, select = c(round_ts, meanlat, sitelat, fullID, tagGroupFactor))) ## get unique hourly detections for small dataframe
data <- data[order(data$round_ts),] ## order by time
out <- by(data, INDICES = data$tagGroupFactor, FUN = function(m){
m <- droplevels(m)
m <- ggplot2::ggplot(m, ggplot2::aes(round_ts, sitelat, colour = fullID, group = fullID))
p <- ggplot2::ggplot(data, ggplot2::aes(round_ts, sitelat, col = fullID, group = fullID))
m + ggplot2::geom_line() + ggplot2::geom_point(pch = 21) + ggplot2::theme_bw() +
ggplot2::labs(title = "Detection time vs Site (ordered by latitude) by Tag", x = "Date", y = "Latitude", colour = "ID") +
ggplot2::facet_wrap("tagGroupFactor") + ggplot2::theme(axis.text.x = element_text(angle = 45, hjust = 1))
})
do.call(gridExtra::grid.arrange, out)
}
fun(jb)
fun(jb, lat.name = "lon")
fun<- function (data, lat.name = "lat", tagsPerPanel = 5) {
if(class(tagsPerPanel) != "numeric") stop('Numeric value required for "tagsPerPanel"')
data = data %>% mutate(hour = 3600*round(ts/3600, 0)) ## round times to the hour
dataGrouped <- dplyr::filter_(data, paste(lat.name, "!=", 0)) %>% group_by(site) %>%
summarise_(.dots = setNames(paste0('mean(',lat.name,')'), 'meanlat')) ## get summary of mean lats by site
data <- inner_join(data, dataGrouped, by = "site") ## join grouped data with data
data <- select(data, id, site, hour, lat, meanlat, fullID) %>% distinct %>% collect %>% as.data.frame
data$hour <- lubridate::as_datetime(data$hour, tz = "UTC")
labs = data$fullID[order(data$id, data$fullID)]
dup = duplicated(labs)
tagLabs = labs[!dup]
tagGroupIDs = data$id[order(data$id, data$fullID)][!dup]
tagGroup = 1 + floor((0:length(tagLabs))/tagsPerPanel)
ngroup = length(tagGroup)
names(tagGroup) = tagLabs
tagGroupFactor = tagGroup[as.character(data$fullID)]
tagGroupLabels = tapply(tagGroupIDs, 1 + floor((0:(length(tagGroupIDs) -
1))/tagsPerPanel), function(data) paste("IDs:", paste(sort(unique(data)),
collapse = ",")))
data$tagGroupFactor = factor(tagGroupFactor, labels = tagGroupLabels,
ordered = TRUE)
data <- unique(subset(data, select = c(hour, meanlat,
site, fullID, tagGroupFactor)))
data <- data[order(data$hour), ]
out <- by(data, INDICES = data$tagGroupFactor, FUN = function(m) {
m <- droplevels(m)
m <- ggplot2::ggplot(m, ggplot2::aes(hour, meanlat,
colour = fullID, group = fullID))
m + ggplot2::geom_line() + ggplot2::geom_point(pch = 21) +
ggplot2::theme_bw() + ggplot2::labs(title = "Detection time vs Latitude by Tag",
x = "Date", y = paste0('mean_', lat.name), colour = "ID") + ggplot2::facet_wrap("tagGroupFactor") +
ggplot2::theme(axis.text.x = element_text(angle = 45, hjust = 1))
})
do.call(gridExtra::grid.arrange, out)
}
fun(jb)
data <- jb
data = data %>% mutate(hour = 3600*round(ts/3600, 0)) ## round times to the hour
fun<- function (data, lat.name = "lat", tagsPerPanel = 5) {
if(class(tagsPerPanel) != "numeric") stop('Numeric value required for "tagsPerPanel"')
data = data %>% mutate(hour = 3600*round(as.numeric(ts)/3600, 0)) ## round times to the hour
dataGrouped <- dplyr::filter_(data, paste(lat.name, "!=", 0)) %>% group_by(site) %>%
summarise_(.dots = setNames(paste0('mean(',lat.name,')'), 'meanlat')) ## get summary of mean lats by site
data <- inner_join(data, dataGrouped, by = "site") ## join grouped data with data
data <- select(data, id, site, hour, lat, meanlat, fullID) %>% distinct %>% collect %>% as.data.frame
data$hour <- lubridate::as_datetime(data$hour, tz = "UTC")
labs = data$fullID[order(data$id, data$fullID)]
dup = duplicated(labs)
tagLabs = labs[!dup]
tagGroupIDs = data$id[order(data$id, data$fullID)][!dup]
tagGroup = 1 + floor((0:length(tagLabs))/tagsPerPanel)
ngroup = length(tagGroup)
names(tagGroup) = tagLabs
tagGroupFactor = tagGroup[as.character(data$fullID)]
tagGroupLabels = tapply(tagGroupIDs, 1 + floor((0:(length(tagGroupIDs) -
1))/tagsPerPanel), function(data) paste("IDs:", paste(sort(unique(data)),
collapse = ",")))
data$tagGroupFactor = factor(tagGroupFactor, labels = tagGroupLabels,
ordered = TRUE)
data <- unique(subset(data, select = c(hour, meanlat,
site, fullID, tagGroupFactor)))
data <- data[order(data$hour), ]
out <- by(data, INDICES = data$tagGroupFactor, FUN = function(m) {
m <- droplevels(m)
m <- ggplot2::ggplot(m, ggplot2::aes(hour, meanlat,
colour = fullID, group = fullID))
m + ggplot2::geom_line() + ggplot2::geom_point(pch = 21) +
ggplot2::theme_bw() + ggplot2::labs(title = "Detection time vs Latitude by Tag",
x = "Date", y = paste0('mean_', lat.name), colour = "ID") + ggplot2::facet_wrap("tagGroupFactor") +
ggplot2::theme(axis.text.x = element_text(angle = 45, hjust = 1))
})
do.call(gridExtra::grid.arrange, out)
}
fun(jb)
fun(jb, lat.name = "lon")
fun<- function (data, coordinate = "lat", tagsPerPanel = 5) {
if(class(tagsPerPanel) != "numeric") stop('Numeric value required for "tagsPerPanel"')
data = data %>% mutate(hour = 3600*round(as.numeric(ts)/3600, 0)) ## round times to the hour
dataGrouped <- dplyr::filter_(data, paste(coordinate, "!=", 0)) %>% group_by(site) %>%
summarise_(.dots = setNames(paste0('mean(',coordinate,')'), 'meanlat')) ## get summary of mean lats by site
data <- inner_join(data, dataGrouped, by = "site") ## join grouped data with data
data <- select(data, id, site, hour, lat, meanlat, fullID) %>% distinct %>% collect %>% as.data.frame
data$hour <- lubridate::as_datetime(data$hour, tz = "UTC")
labs = data$fullID[order(data$id, data$fullID)]
dup = duplicated(labs)
tagLabs = labs[!dup]
tagGroupIDs = data$id[order(data$id, data$fullID)][!dup]
tagGroup = 1 + floor((0:length(tagLabs))/tagsPerPanel)
ngroup = length(tagGroup)
names(tagGroup) = tagLabs
tagGroupFactor = tagGroup[as.character(data$fullID)]
tagGroupLabels = tapply(tagGroupIDs, 1 + floor((0:(length(tagGroupIDs) -
1))/tagsPerPanel), function(data) paste("IDs:", paste(sort(unique(data)),
collapse = ",")))
data$tagGroupFactor = factor(tagGroupFactor, labels = tagGroupLabels,
ordered = TRUE)
data <- unique(subset(data, select = c(hour, meanlat,
site, fullID, tagGroupFactor)))
data <- data[order(data$hour), ]
out <- by(data, INDICES = data$tagGroupFactor, FUN = function(m) {
m <- droplevels(m)
m <- ggplot2::ggplot(m, ggplot2::aes(hour, meanlat,
colour = fullID, group = fullID))
m + ggplot2::geom_line() + ggplot2::geom_point(pch = 21) +
ggplot2::theme_bw() + ggplot2::labs(title = "Detection time vs Latitude by Tag",
x = "Date", y = paste0('mean_', coordinate), colour = "ID") + ggplot2::facet_wrap("tagGroupFactor") +
ggplot2::theme(axis.text.x = element_text(angle = 45, hjust = 1))
})
do.call(gridExtra::grid.arrange, out)
}
fun(jb)
fun(jb, coordinate = "lon")
fun<- function(data, coordinate = "lat", tagsPerPanel = 5){
if(class(tagsPerPanel) != "numeric") stop('Numeric value required for "tagsPerPanel"')
data = data %>% mutate(round_ts = 3600*round(as.numeric(ts)/3600, 0)) ## round times to the hour
#data = distinct(select(data, id, site, round_ts, lat, recvDeployLat, lon, recvDeployLon, fullID))
dataGrouped <- dplyr::filter_(data, paste(coordinate, "!=", 0)) %>% group_by(site) %>%
summarise_(.dots = setNames(paste0('mean(',coordinate,')'), 'meanlat')) ## get summary of mean lats by site
data <- inner_join(data, dataGrouped, by = "site") ## join grouped data with data
data <- select(data, id, site, round_ts, lat, meanlat, fullID) %>% distinct %>% collect %>% as.data.frame
data$meanlat = round(data$meanlat, digits = 2) ## round to 2 significant digits
data$sitelat <- as.factor(paste(data$site, data$meanlat, sep = " ")) ## new column with site and lat
data <- within(data, sitelat <- reorder(sitelat, (lat))) ## order sitelat by latitude
data$round_ts <- lubridate::as_datetime(data$round_ts, tz = "UTC")
## We want to plot multiple tags per panel, so sort their labels and create a grouping factor
## Note that labels are sorted in increasing order by ID
labs = data$fullID[order(data$id,data$fullID)]
dup = duplicated(labs)
tagLabs = labs[!dup]
tagGroupIDs = data$id[order(data$id,data$fullID)][!dup]
tagGroup = 1 + floor((0:length(tagLabs)) / tagsPerPanel)
ngroup = length(tagGroup)
names(tagGroup) = tagLabs
tagGroupFactor = tagGroup[as.character(data$fullID)]
tagGroupLabels = tapply(tagGroupIDs, 1 + floor((0:(length(tagGroupIDs)-1)) / tagsPerPanel), function(data) paste("IDs:", paste(sort(unique(data)), collapse=",")))
data$tagGroupFactor = factor(tagGroupFactor, labels=tagGroupLabels, ordered=TRUE)
data <- unique(subset(data, select = c(round_ts, meanlat, sitelat, fullID, tagGroupFactor))) ## get unique hourly detections for small dataframe
data <- data[order(data$round_ts),] ## order by time
out <- by(data, INDICES = data$tagGroupFactor, FUN = function(m){
m <- droplevels(m)
m <- ggplot2::ggplot(m, ggplot2::aes(round_ts, sitelat, colour = fullID, group = fullID))
p <- ggplot2::ggplot(data, ggplot2::aes(round_ts, sitelat, col = fullID, group = fullID))
m + ggplot2::geom_line() + ggplot2::geom_point(pch = 21) + ggplot2::theme_bw() +
ggplot2::labs(title = "Detection time vs Site (ordered by latitude) by Tag", x = "Date", y = "Latitude", colour = "ID") +
ggplot2::facet_wrap("tagGroupFactor") + ggplot2::theme(axis.text.x = element_text(angle = 45, hjust = 1))
})
do.call(gridExtra::grid.arrange, out)
}
fun(jb)
fun(jb, coordinate = "lon")
fun<- function(data, coordinate = "lat", tagsPerPanel = 5){
if(class(tagsPerPanel) != "numeric") stop('Numeric value required for "tagsPerPanel"')
data = data %>% mutate(round_ts = 3600*round(as.numeric(ts)/3600, 0)) ## round times to the hour
#data = distinct(select(data, id, site, round_ts, lat, recvDeployLat, lon, recvDeployLon, fullID))
dataGrouped <- dplyr::filter_(data, paste(coordinate, "!=", 0)) %>% group_by(site) %>%
summarise_(.dots = setNames(paste0('mean(',coordinate,')'), 'meanlat')) ## get summary of mean lats by site
data <- inner_join(data, dataGrouped, by = "site") ## join grouped data with data
data <- select(data, id, site, round_ts, lat, meanlat, fullID) %>% distinct %>% collect %>% as.data.frame
data$meanlat = round(data$meanlat, digits = 2) ## round to 2 significant digits
data$sitelat <- as.factor(paste(data$site, data$meanlat, sep = " ")) ## new column with site and lat
data <- within(data, sitelat <- reorder(sitelat, (lat))) ## order sitelat by latitude
data$round_ts <- lubridate::as_datetime(data$round_ts, tz = "UTC")
## We want to plot multiple tags per panel, so sort their labels and create a grouping factor
## Note that labels are sorted in increasing order by ID
labs = data$fullID[order(data$id,data$fullID)]
dup = duplicated(labs)
tagLabs = labs[!dup]
tagGroupIDs = data$id[order(data$id,data$fullID)][!dup]
tagGroup = 1 + floor((0:length(tagLabs)) / tagsPerPanel)
ngroup = length(tagGroup)
names(tagGroup) = tagLabs
tagGroupFactor = tagGroup[as.character(data$fullID)]
tagGroupLabels = tapply(tagGroupIDs, 1 + floor((0:(length(tagGroupIDs)-1)) / tagsPerPanel), function(data) paste("IDs:", paste(sort(unique(data)), collapse=",")))
data$tagGroupFactor = factor(tagGroupFactor, labels=tagGroupLabels, ordered=TRUE)
data <- unique(subset(data, select = c(round_ts, meanlat, sitelat, fullID, tagGroupFactor))) ## get unique hourly detections for small dataframe
data <- data[order(data$round_ts),] ## order by time
out <- by(data, INDICES = data$tagGroupFactor, FUN = function(m){
m <- droplevels(m)
m <- ggplot2::ggplot(m, ggplot2::aes(round_ts, sitelat, colour = fullID, group = fullID))
p <- ggplot2::ggplot(data, ggplot2::aes(round_ts, sitelat, col = fullID, group = fullID))
m + ggplot2::geom_line() + ggplot2::geom_point(pch = 21) + ggplot2::theme_bw() +
ggplot2::labs(title = "Detection time vs Site (ordered by latitude) by Tag", x = "Date", y = paste0('Site ordered by ',coordinate), colour = "ID") +
ggplot2::facet_wrap("tagGroupFactor") + ggplot2::theme(axis.text.x = element_text(angle = 45, hjust = 1))
})y = paste0('mean_', coordinate), colour = "ID")
do.call(gridExtra::grid.arrange, out)
}
fun<- function(data, coordinate = "lat", tagsPerPanel = 5){
if(class(tagsPerPanel) != "numeric") stop('Numeric value required for "tagsPerPanel"')
data = data %>% mutate(round_ts = 3600*round(as.numeric(ts)/3600, 0)) ## round times to the hour
#data = distinct(select(data, id, site, round_ts, lat, recvDeployLat, lon, recvDeployLon, fullID))
dataGrouped <- dplyr::filter_(data, paste(coordinate, "!=", 0)) %>% group_by(site) %>%
summarise_(.dots = setNames(paste0('mean(',coordinate,')'), 'meanlat')) ## get summary of mean lats by site
data <- inner_join(data, dataGrouped, by = "site") ## join grouped data with data
data <- select(data, id, site, round_ts, lat, meanlat, fullID) %>% distinct %>% collect %>% as.data.frame
data$meanlat = round(data$meanlat, digits = 2) ## round to 2 significant digits
data$sitelat <- as.factor(paste(data$site, data$meanlat, sep = " ")) ## new column with site and lat
data <- within(data, sitelat <- reorder(sitelat, (lat))) ## order sitelat by latitude
data$round_ts <- lubridate::as_datetime(data$round_ts, tz = "UTC")
## We want to plot multiple tags per panel, so sort their labels and create a grouping factor
## Note that labels are sorted in increasing order by ID
labs = data$fullID[order(data$id,data$fullID)]
dup = duplicated(labs)
tagLabs = labs[!dup]
tagGroupIDs = data$id[order(data$id,data$fullID)][!dup]
tagGroup = 1 + floor((0:length(tagLabs)) / tagsPerPanel)
ngroup = length(tagGroup)
names(tagGroup) = tagLabs
tagGroupFactor = tagGroup[as.character(data$fullID)]
tagGroupLabels = tapply(tagGroupIDs, 1 + floor((0:(length(tagGroupIDs)-1)) / tagsPerPanel), function(data) paste("IDs:", paste(sort(unique(data)), collapse=",")))
data$tagGroupFactor = factor(tagGroupFactor, labels=tagGroupLabels, ordered=TRUE)
data <- unique(subset(data, select = c(round_ts, meanlat, sitelat, fullID, tagGroupFactor))) ## get unique hourly detections for small dataframe
data <- data[order(data$round_ts),] ## order by time
out <- by(data, INDICES = data$tagGroupFactor, FUN = function(m){
m <- droplevels(m)
m <- ggplot2::ggplot(m, ggplot2::aes(round_ts, sitelat, colour = fullID, group = fullID))
p <- ggplot2::ggplot(data, ggplot2::aes(round_ts, sitelat, col = fullID, group = fullID))
m + ggplot2::geom_line() + ggplot2::geom_point(pch = 21) + ggplot2::theme_bw() +
ggplot2::labs(title = "Detection time vs Site (ordered by latitude) by Tag", x = "Date", y = paste0('Site ordered by ',coordinate), colour = "ID") +
ggplot2::facet_wrap("tagGroupFactor") + ggplot2::theme(axis.text.x = element_text(angle = 45, hjust = 1))
})
do.call(gridExtra::grid.arrange, out)
}
fun(jb, "lon")
fun<- function(data, coordinate = "lat", tagsPerPanel = 5){
if(class(tagsPerPanel) != "numeric") stop('Numeric value required for "tagsPerPanel"')
data = data %>% mutate(round_ts = 3600*round(as.numeric(ts)/3600, 0)) ## round times to the hour
#data = distinct(select(data, id, site, round_ts, lat, recvDeployLat, lon, recvDeployLon, fullID))
dataGrouped <- dplyr::filter_(data, paste(coordinate, "!=", 0)) %>% group_by(site) %>%
summarise_(.dots = setNames(paste0('mean(',coordinate,')'), 'meanlat')) ## get summary of mean lats by site
data <- inner_join(data, dataGrouped, by = "site") ## join grouped data with data
data <- select(data, id, site, round_ts, lat, meanlat, fullID) %>% distinct %>% collect %>% as.data.frame
data$meanlat = round(data$meanlat, digits = 2) ## round to 2 significant digits
data$sitelat <- as.factor(paste(data$site, data$meanlat, sep = " ")) ## new column with site and lat
data <- within(data, sitelat <- reorder(sitelat, (meanlat))) ## order sitelat by latitude
data$round_ts <- lubridate::as_datetime(data$round_ts, tz = "UTC")
## We want to plot multiple tags per panel, so sort their labels and create a grouping factor
## Note that labels are sorted in increasing order by ID
labs = data$fullID[order(data$id,data$fullID)]
dup = duplicated(labs)
tagLabs = labs[!dup]
tagGroupIDs = data$id[order(data$id,data$fullID)][!dup]
tagGroup = 1 + floor((0:length(tagLabs)) / tagsPerPanel)
ngroup = length(tagGroup)
names(tagGroup) = tagLabs
tagGroupFactor = tagGroup[as.character(data$fullID)]
tagGroupLabels = tapply(tagGroupIDs, 1 + floor((0:(length(tagGroupIDs)-1)) / tagsPerPanel), function(data) paste("IDs:", paste(sort(unique(data)), collapse=",")))
data$tagGroupFactor = factor(tagGroupFactor, labels=tagGroupLabels, ordered=TRUE)
data <- unique(subset(data, select = c(round_ts, meanlat, sitelat, fullID, tagGroupFactor))) ## get unique hourly detections for small dataframe
data <- data[order(data$round_ts),] ## order by time
out <- by(data, INDICES = data$tagGroupFactor, FUN = function(m){
m <- droplevels(m)
m <- ggplot2::ggplot(m, ggplot2::aes(round_ts, sitelat, colour = fullID, group = fullID))
p <- ggplot2::ggplot(data, ggplot2::aes(round_ts, sitelat, col = fullID, group = fullID))
m + ggplot2::geom_line() + ggplot2::geom_point(pch = 21) + ggplot2::theme_bw() +
ggplot2::labs(title = "Detection time vs Site (ordered by latitude) by Tag", x = "Date", y = paste0('Site ordered by ',coordinate), colour = "ID") +
ggplot2::facet_wrap("tagGroupFactor") + ggplot2::theme(axis.text.x = element_text(angle = 45, hjust = 1))
})
do.call(gridExtra::grid.arrange, out)
}
fun(jb, "lon")
fun(alltags, "lon")
getwd()
install("motus")
require(devtools)
require(roxygen2)
install.packages("roxygen")
install.packages("roxygen2")
require(roxygen2)
getwd()
install("motus")
install("motusPackage")
require(roxygen2)
require(devtools)
document()
.onLoad = function(...) {
## make sure the motusClient package is installed and loaded
## Note: eventually, when the CRAN version of devtools supports
## loading dependent packages from github via the "Remotes:" field,
## this section can be replaced with a simple `require(motusClient)`
if(!suppressWarnings(suppressMessages(require("motusClient",
quietly=TRUE, character.only=TRUE)))) {
devtools::install_github("jbrzusto/motusClient")
suppressMessages(require("motusClient", character.only=TRUE))
}
addHook("ensureDBTables", updateMotusDb)
}
rm(siteSumDaily)
siteSumDaily <- function(data, units = "hours"){
data <- select(data, motusTagID, sig, site, ts) %>% distinct %>% collect %>% as.data.frame
data$ts <- as_datetime(data$ts, tz = "UTC")
data$date <- as.Date(data$ts)
grouped <- dplyr::group_by(data, site, date)
site_sum <- dplyr::summarise(grouped,
first_ts=min(ts),
last_ts=max(ts),
tot_ts = difftime(max(ts), min(ts), units = units),
num_tags = length(unique(motusTagID)),
num_det = length(ts))
return(site_sum)
}
.onLoad = function(...) {
## make sure the motusClient package is installed and loaded
## Note: eventually, when the CRAN version of devtools supports
## loading dependent packages from github via the "Remotes:" field,
## this section can be replaced with a simple `require(motusClient)`
if(!suppressWarnings(suppressMessages(require("motusClient",
quietly=TRUE, character.only=TRUE)))) {
devtools::install_github("jbrzusto/motusClient")
suppressMessages(require("motusClient", character.only=TRUE))
}
addHook("ensureDBTables", updateMotusDb)
}
z.onLoad = function(...) {
## make sure the motusClient package is installed and loaded
## Note: eventually, when the CRAN version of devtools supports
## loading dependent packages from github via the "Remotes:" field,
## this section can be replaced with a simple `require(motusClient)`
if(!suppressWarnings(suppressMessages(require("motusClient",
quietly=TRUE, character.only=TRUE)))) {
devtools::install_github("jbrzusto/motusClient")
suppressMessages(require("motusClient", character.only=TRUE))
}
addHook("ensureDBTables", updateMotusDb)
}
document()
document()
document()
getwd()
require(motus)
rem(siteSumDaily)
rm(siteTrans)
require(motus)
tagme("Lotek-221", update = TRUE, dir = "/Users/zoecrysler/Documents/BSC 2016/motus data/pam data/)
)
"""
tagme("Lotek-221", update = TRUE, dir = "/Users/zoecrysler/Documents/BSC 2016/motus data/pam data/")
