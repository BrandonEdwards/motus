% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/makeAlltagsView.R
\name{makeAlltagsView}
\alias{makeAlltagsView}
\title{create a virtual table of tag detections linked with all metadata.}
\usage{
makeAlltagsView(db, name = "alltags")
}
\arguments{
\item{db}{dplyr src_sqlite to detections database}

\item{name}{character scalar; name for the virtual table.
Default: 'alltags'.}
}
\value{
a dplyr::tbl which refers to the newly-created virtual table.
}
\description{
Creates a virtual table (really a 'view') in a motus database that
links each tag detection to all metadata available for the tag and
receiver.
}
\note{
The new virtual table replaces any previous virtual table by the same
name in \code{db}.  The virtual table is an SQL VIEW, which will persist in \code{db}
across R sessions.
}
\author{
John Brzustowski \email{jbrzusto@REMOVE_THIS_PART_fastmail.fm}

Implementation details:

For both tags and receivers, deployment meta-data has to be looked
up by detection ("hit") timestamp; i.e. we need the latest
deployment record which is still before the hit timestamp.  So we
are joining the hit table to the deployment table by a timestamp on
the hit and a greatest lower bound for that timestamp in the
deployment table.  It would be nice if there were an SQL
"LOWER JOIN" operator, which instead of joining on exact key value,
would join a key on the left to its greatest lower bound on the
right.  (and similary, an "UPPER JOIN" operator to bind to the
least upper bound on the right.)  For keys with B-tree indexes,
this would be as fast as an exact join.

We can instead code this as a subquery like so:

CREATE TABLE hits (ts double, tagID integer);
CREATE TABLE tagDeps (tsStart double, tsEnd double, tagID integer, info char);

   SELECT t1.*, t2.info from hits as t1 left join tagDeps as t2 on
   t2.tagID = t1.tagID and t2.tsStart = (select max(t3.tsStart) from
   tagDeps as t3 where t3.tagID=t2.tagID and t3.tsStart <= t1.ts and
   t3.tsEnd >= t1.ts)

This will yield NA for the 'info' field when there is no tag
deployment covering the range.  Running EXPLAIN on this query in
sqlite suggests it optimizes well.

GPS fixes

If this is a receiver database (with detections from a single receiver),
it will contain a table called \code{GPS} with receiver GPS fixes, and these
are used in the view to provide lat/lon/elevation.

Otherwise, lat/lon/elevation come from the recvGPS table.  For most receiver
deployments, that table will contain only one fix, but for mobile deployments,
the table will contain a time series of fixes.  The view will use this table
to provide lat/lon/elevation.
}
